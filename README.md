# review

###Index
Index  - структура данных, которая позволяет извлекать данные из таблицы быстрее без необходимоcти скниаровать какждую строку таблицы Например можно расположить данные в алфавитном порядке.

Упрощённо некластерный индекс можно представить как отдельную таблицу, каждая строка в которой ссылается на одну или несколько строк в таблице с данными. Строки в индексной таблице упорядочены и  сгруппированы по значениям ключевых полей

При использовании «обычного», некластерного индекса, задача поиска сильно ускоряется.
 Во-первых, индексная таблица весит много меньше таблицы с данными, а значит элементарно может быть прочитана быстрее.
 Во-вторых, СУБД чаще всего стараются кешировать индексы в оперативную память, которая сама по себе много шустрее жёсткого диска
 *. В-третьих, в индексах отсутствуют дублирующиеся строки. А значит, как только мы нашли первое значение,  поиск можно прекращать — оно же и последнее. 
 В-четвёртых, данные в индексе отсортированы. 
 А в-третьих и в-четвёртых вместе позволяют использовать алгоритм бинарного поиска (он же метод деления пополам), эффективность которого многократно превосходит простой перебор.
 
 
Обычно индексы создаются вместе с таблицей, но если требуется сделать индекс отдельно, то используется Alter Table


Кластерные индексы отличаются от некластерных точно так же, как оглавление книги отличается от алфавитного указателя. Алфавитный указатель (некластерный индекс) для точного слова (значения) даёт точные номера страниц (строки в БД). Оглавление же указывает диапазон страниц, соответствующих определённой главе, в которой уже найдётся искомое слово. Причём каждая глава, если она достаточно велика, может содержать собственное оглавление.

Кластерный индекс — это древовидная структура данных, при которой значения индекса хранятся вместе с данными, им соответствующими. И индексы, и данные при такой организации упорядочены. При добавлении новой строки в таблицу, она дописывается не в конец файла*, не в конец плоского списка, а в нужную ветку древовидной структуры, соответствующую ей по сортировке


Индексы бывают разных типов. По способу хранения данных отличают кластерные и обычные индексы.

Обычно индекс — это отсортированный набор данных колонки, по которой он построен. Например для таблицы:

| id | name  |
| 1  | Den   |
| 3  | Lenin |
| 2  | Thor  |
Индекс по колонке ID будет выглядеть так:
| id |
| 1  | -> 1 строка
| 2  | -> 3 строка
| 3  | -> 2 строка
Индекс будет хранить ссылки на данные каждой строки для каждого значения ID.
Кластерный индекс (или кластерный ключ) сохраняет не только значения колонки в отсортированном виде, а и данные всей строки:
| id | name  |
| 1  | Den   |
| 2  | Thor  |
| 3  | Lenin |
Это позволяет минимизировать количество операций чтения с диска при работе с таким индексом. В таблице может быть только один кластерный индекс.

### TRUNCATE и DELETE
Основные отличия операторов TRUNCATE и DELETE, которые могут присутствовать в различных реализациях СУБД:

Операция TRUNCATE не записывает в журнал событий удаление отдельных строк. Вследствие чего не может активировать триггеры.
После операции TRUNCATE для некоторых СУБД (например, Oracle) следует неявная операция COMMIT. Поэтому удаленные в таблице записи нельзя восстановить операцией ROLLBACK. Но существуют и СУБД, в которых операция TRUNCATE может участвовать в транзакциях, например, PostgreSQL и Microsoft SQL Server.
Операция DELETE блокирует каждую строку, а TRUNCATE — всю таблицу.
Операция TRUNCATE не возвращает какого-то осмысленного значения (обычно возвращает 0) в отличие от DELETE, которая возвращает число удаленных строк.
Операция TRUNCATE в некоторых СУБД (например, MySQL или Microsoft SQL Server), сбрасывает значение счетчиков (для полей с AUTOINCREMENT / IDENTITY). В PostgreSQL для сброса счётчиков необходимо указывать модификатор RESTART IDENTITY.
Операция TRUNCATE в некоторых СУБД (например, MySQL, PostgreSQL или Microsoft SQL Server) запрещена для таблиц, содержащих внешние ключи других таблиц. В PostgreSQL существует, однако, модификатор CASCADE, который разрешает TRUNCATE в этой ситуации – данные из зависимых таблиц удаляются в той же транзакции.
В SQLite операция как таковая отсутствует, но есть оптимизация операции DELETE, которая «значительно ускоряет её работу, если отсутствует аргумент WHERE».
Реализация оператора TRUNCATE может зависеть от выбора конкретной СУБД. Поэтому в каждом случае необходимо изучать документацию выбранной системы.

Инструкция TRUNCATE TABLE обладает следующими преимуществами по сравнению с инструкцией DELETE.
Используется меньший объем журнала транзакций.
Инструкция DELETE производит удаление по одной строке и заносит в журнал транзакций запись для каждой удаляемой строки. Инструкция TRUNCATE TABLE удаляет данные, освобождая страницы данных, используемые для хранения данных таблиц, и в журнал транзакций записывает только данные об освобождении страниц.
Обычно используется меньшее количество блокировок.
Если инструкция DELETE выполняется с блокировкой строк, для удаления блокируется каждая строка таблицы. Инструкция TRUNCATE TABLE всегда блокирует таблицу (включая блокировку схемы (SCH-M)) и страницу, но не каждую строку.
В таблице остается нулевое количество страниц, без исключений.
После выполнения инструкции DELETE в таблице могут все еще оставаться пустые страницы. Например, чтобы освободить пустые страницы в куче, необходима, как минимум, монопольная блокировка таблицы (LCK_M_X). Если операция удаления не использует блокировку таблицы, таблица (куча) будет содержать множество пустых страниц. В индексах после операции удаления могут оказаться пустые страницы, хотя эти страницы будут быстро освобождены процессом фоновой очистки.
Инструкция TRUNCATE TABLE удаляет все строки таблицы, но структура таблицы и ее столбцы, ограничения, индексы и т. п. сохраняются. Чтобы удалить не только данные таблицы, но и ее определение, следует использовать инструкцию DROP TABLE.
Если таблица содержит столбец идентификаторов, счетчик этого столбца сбрасывается до начального значения, определенного для этого столбца. Если начальное значение не задано, используется значение по умолчанию, равное 1. Чтобы сохранить столбец идентификаторов, используйте инструкцию DELETE.

### Transaction
Транзакция
группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными. Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность данных и независимо от параллельно идущих других транзакций, либо не выполнена вообще, и тогда она не должна произвести никакого эффекта. Транзакции обрабатываются транзакционными системами, в процессе работы которых создаётся история транзакций.
Различают последовательные (обычные), параллельные и распределённые транзакции. Распределённые транзакции подразумевают использование более чем одной транзакционной системы и требуют намного более сложной логики (например, two-phase commit — двухфазный протокол фиксации транзакции). Также в некоторых системах реализованы автономные транзакции, или под-транзакции, которые являются автономной частью родительской

### Union
Операция UNION позволяет объединить несколько результатов выборки в один набор строк. Именно объединение строк отличает эту операцию от соединения таблиц через JOIN, которая присоединяет столбцы


Самый простой вид соединения INNER JOIN – внутреннее соединение. Этот вид джойна выведет только те строки, если условие соединения выполняется (является истинным, т.е. TRUE). В запросах необязательно прописывать INNER – если написать только JOIN, то СУБД по умолчанию выполнить именно внутреннее соединение.

Левое и правое соединения еще называют внешними. Главное их отличие от внутреннего соединения в том, что строка из левой (для LEFT JOIN) или из правой таблицы (для RIGHT JOIN) попадет в результаты в любом случае. 

Еще один вид соединения, который осталось рассмотреть – полное внешнее соединение.

Этот вид джойна вернет все строки из всех таблиц, участвующих в соединении, соединив между собой те, которые подошли под условие ON.


